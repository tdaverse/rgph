---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# rgph

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://lifecycle.r-lib.org/articles/stages.html#experimental)
<!-- badges: end -->

Reeb graphs arise as low-dimensional quotients of topological spaces by level set--based equivalence.
The Reeb graph's topological structure is informative of that of the original space but quicker and easier to compute.

**rgph** provides an S3 class and constructors for Reeb graphs, bindings to the [`ReebGraphPairing`](https://github.com/USFDataVisualization/ReebGraphPairing) Java library for pairing their critical points, post-processing to extended persistent homology, and methods to accommodate `igraph` and `network` objects and to streamline the process.

## Installation

You can install the development version of **rgph** from [GitHub](https://github.com/) with:

``` r
# install.packages("pak")
pak::pak("tdaverse/rgph")
```

We expect to submit to CRAN soon!

## Example

```{r attach-package}
library(rgph)
```

The running example from [Tu, Hajij, and Rosen (2019)](https://doi.org/10.1007/978-3-030-33720-9_8) can be read in from an installed data file:

```{r read-example}
( ex_file <- system.file("extdata/running_example.txt", package = "rgph") )
( ex_reeb <- read_reeb_graph(ex_file) )
```

The Reeb graph printout comprises the edgelist.
In this example, the function value at each vertex is (up to numbering convention) the index of that vertex.
The R indexing starts at 1, while the function values, printed in parentheses, reflect the original indexing from 0.

While no `plot()` method is provided yet, a layered layout from [**igraph**](https://r.igraph.org/) may be helpful.
Here we negate the values of the Reeb function so that vertices with higher (original) values are positioned higher in the plot:

```{r plot-example, fig.width=8, fig.height=8, out.width="60%"}
ex_igraph <- as_igraph(ex_reeb, values = "depth")
ex_layout <- igraph::layout_with_sugiyama(
  ex_igraph,
  layers = -igraph::vertex_attr(ex_igraph, "depth")
)
plot(ex_igraph, layout = ex_layout)
```

While low-dimensional, Reeb graphs are intricate structures, whereas most statistical applications require numerical summary statistics.
A meaningful topological signature of a Reeb graph (hence of its parent space) can be obtained by pairing its critical points.

Tu, Hajij, and Rosen proposed a clever single-pass algorithm, "propagate-and-pair", which outperformed a multiple-pass algorithm (based on standard procedures at the time) on most Reeb graphs included in a comparison.
Both methods are provided, which the user may control using the `method` argument:

```{r pair-example}
( ex_pairs <- reeb_graph_pairs(ex_reeb, method = "single") )
```

Each end of a pairing is either a local extremum (minimum or maximum) or a fork (upward or downward).
These types are indicated in the printout by bullets and inequality signs, respectively; refer to the plot above to see how the pairings exhaust the vertex--edge incidences.

The pairing output can be converted to extended persistence diagrams using the `persistence` class from [**phutil**](https://tdaverse.github.io/phutil/) and plotted using the `diagram` method from [**TDA**](https://github.com/compTAG/r-tda):

```{r persist-example, fig.width=5, fig.height=5, out.width="60%"}
( ex_ph <- reeb_graph_persistence(ex_pairs, scale = "index") )
TDA::plot.diagram(as.data.frame(ex_ph), asp = 1)
```

The plot overlays 4 sub-diagrams, two of which lie below the diagonal because they encode features in extended persistence whose births occur at larger function values than their deaths (explained in detail by [CarriÃ¨re & Oudot (2018)](https://doi.org/10.1007/s10208-017-9370-z); compare to Fig. 1 of Tu, Hajij, and Rosen):

* min--max pairs that encode connected components, constitutive of degree-$0$ positive extended persistence; the pair $(1,16)$
* min--down pairs that encode merges, in degree-$0$ ordinary persistence; e.g. the pair $(5,7)$
* up--max pairs that encode splits, in degree-$1$ relative persistence; the pair $(15,14)$
* up--down pairs that encode cycles, in degree-$1$ negative extended persistence; e.g. the pair $(13,9)$
