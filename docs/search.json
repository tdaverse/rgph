[{"path":"/articles/benchmark.html","id":"the-running-example","dir":"Articles","previous_headings":"","what":"The running example","title":"Runtime Comparison of Critical Point Pairing Algorithms","text":"illustrate, compare results two algorithms running example Tu &al (2018): expect resulting data frames equivalent, output contains attributes method elapsed_time expect different. ignore attributes, find results agree: reason, omit default check benchmarking run: R bindings equivalent; total runtimes higher comparing Java programs directly, differences . Indeed, allocated memory exactly . However, single-pass algorithm—Propagate Pair—marginal improvement multiple-pass merge pairing algorithm.","code":"ex_file <- system.file(\"extdata\", \"running_example.txt\", package = \"rgph\") ex_reeb <- read_reeb_graph(ex_file) ( ex_multi <- reeb_graph_pairs(ex_reeb, method = \"multi_pass\") ) #> Reeb graph critical pairing (8 pairs): #>  1 ( 0) •- ... -• 16 (15) #>  2 ( 1) •- ... >-  3 ( 2) #>  5 ( 4) •- ... >-  7 ( 6) #>  8 ( 7) •- ... >- 11 (10) #>  6 ( 5) -< ... >- 10 ( 9) #>  4 ( 3) -< ... >- 12 (11) #>  9 ( 8) -< ... >- 13 (12) #> 14 (13) -< ... -• 15 (14) ( ex_single <- reeb_graph_pairs(ex_reeb, method = \"single_pass\") ) #> Reeb graph critical pairing (8 pairs): #>  1 ( 0) •- ... -• 16 (15) #>  2 ( 1) •- ... >-  3 ( 2) #>  5 ( 4) •- ... >-  7 ( 6) #>  8 ( 7) •- ... >- 11 (10) #>  6 ( 5) -< ... >- 10 ( 9) #>  4 ( 3) -< ... >- 12 (11) #>  9 ( 8) -< ... >- 13 (12) #> 14 (13) -< ... -• 15 (14) all.equal(ex_multi, ex_single) #> [1] \"Attributes: < Component \\\"elapsed_time\\\": Mean relative difference: 0.6552826 >\" #> [2] \"Attributes: < Component \\\"method\\\": 1 string mismatch >\" all.equal(ex_multi, ex_single, check.attributes = FALSE) #> [1] TRUE bench::mark(   multi = reeb_graph_pairs(ex_reeb, method = \"multi_pass\"),   single = reeb_graph_pairs(ex_reeb, method = \"single_pass\"),   check = FALSE ) #> # A tibble: 2 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 multi         285µs    372µs     2276.    1.24KB     8.34 #> 2 single        265µs    290µs     3180.    1.24KB    14.8"},{"path":"/articles/benchmark.html","id":"a-more-complex-case","dir":"Articles","previous_headings":"","what":"A more complex case","title":"Runtime Comparison of Critical Point Pairing Algorithms","text":"exported object flower reeb_graph constructed flower mesh, one 12 AIM@SHAPE collection used Tu &al benchmark algorithms. Among , contains critical points, better illustrate difference algorithms computationally intensive settings. However, Reeb graph contains isolated vertices, contribute positive-persistent features output must dropped calculation, lest seize algorithms: benchmark results reflective algorithms’ requirements, manually drop points first: Reeb graph, Propagate Pair outperforms multi-pass algorithm roughly factor 3.","code":"# print only a few edges for illustration print(flower, n = 4) #> Reeb graph with 132 vertices and 196 edges on [0,10]: #> 123 (0.000000) --  24 (2.472221) #>  24 (2.472221) --  21 (3.478179) #>  24 (2.472221) --  21 (3.478179) #>  21 (3.478179) --  40 (3.572073) #> ... # print only a few pairs for illustration print(reeb_graph_pairs(flower, method = \"multi_pass\"), n = 4) #> Reeb graph critical pairing (66 pairs): #> 123 (0.000000) •- ... -• 22 (10.000000) #>  24 (2.472221) -< ... >- 21 ( 3.478179) #>  40 (3.572073) -< ... >- 43 ( 3.690718) #> 120 (3.626757) -< ... >- 78 ( 3.753133) flower <- rgph:::drop_reeb_graph_points(flower) bench::mark(   multi = reeb_graph_pairs(flower, method = \"multi_pass\"),   single = reeb_graph_pairs(flower, method = \"single_pass\"),   check = FALSE ) #> # A tibble: 2 × 6 #>   expression      min   median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl> #> 1 multi         596µs    634µs     1543.      24KB     6.16 #> 2 single        519µs    617µs     1512.      24KB     8.38"},{"path":"/articles/benchmark.html","id":"how-performance-and-improvement-scale","dir":"Articles","previous_headings":"","what":"How performance and improvement scale","title":"Runtime Comparison of Critical Point Pairing Algorithms","text":"Finally, compare algorithms scale. Vertex edge data provided three random merge tree Reeb graphs exponential size scale. converted split trees negating vertex values benchmarked separately stacked. (Note single-pass algorithm found superior multi-pass algorithm split trees inferior merge trees.) plotting run times benchmarks, can visualize differences runtimes algorithms variability runtimes.  single-pass advantage appears grow size. ratio medians quantifies :","code":"# collect split tree Reeb graphs tree_files <- vapply(   c(     `10` = \"10_tree_iterations.txt\",     `100` = \"100_tree_iterations.txt\",     `1000` = \"1000_tree_iterations.txt\"   ),   function(f) system.file(\"extdata\", f, package = \"rgph\"),   \"\" ) tree_reebs <- lapply(tree_files, read_reeb_graph) tree_reebs <- lapply(tree_reebs, function(rg) { rg$values <- -rg$values; rg }) # aggregate benchmark comparisons tree_bench <- tibble() for (i in seq_along(tree_reebs)) {   bm <- bench::mark(     multi = reeb_graph_pairs(tree_reebs[[i]], method = \"multi_pass\"),     single = reeb_graph_pairs(tree_reebs[[i]], method = \"single_pass\"),     check = FALSE   )   bm <- transmute(     bm,     method = as.character(expression),     n_itr, time, memory   )   bm <- relocate(mutate(bm, size = as.integer(names(tree_files)[[i]])), size)   tree_bench <- bind_rows(tree_bench, bm) } # plot runtime results tree_bench %>%   select(size, method, time) %>%   unnest(time) %>%   ggplot(aes(x = as.factor(size), y = time * 1e3)) +   geom_boxplot(aes(color = method, shape = method)) +   scale_y_continuous(     transform = \"log1p\",     labels = scales::label_number(suffix = \"ms\")   ) +   labs(x = \"tree size\", y = \"run time\") tree_bench %>%   transmute(size, method, median = vapply(time, median, 0.)) %>%   pivot_wider(id_cols = size, names_from = method, values_from = median) %>%   transmute(size, ratio = single / multi) #> # A tibble: 3 × 2 #>    size ratio #>   <int> <dbl> #> 1    10 0.974 #> 2   100 0.776 #> 3  1000 0.587"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Satyajit Mohanty. Author. Shubham Singh. Author. Jason Cory Brunson. Author, maintainer. Paul Rosen. Copyright holder, contributor.            ReebGraphPairing; GPL-3 license Junyi Tu. Copyright holder, contributor.            ReebGraphPairing; GPL-3 license","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Mohanty S, Singh S, Brunson J (2026). rgph: Pair Critical Points Compute Persistent Homology Reeb Graphs. doi:10.32614/CRAN.package.rgph, R package version 0.1.0, https://CRAN.R-project.org/package=rgph.","code":"@Manual{,   title = {rgph: Pair Critical Points and Compute Persistent Homology of Reeb Graphs},   author = {Satyajit Mohanty and Shubham Singh and Jason Cory Brunson},   year = {2026},   note = {R package version 0.1.0},   url = {https://CRAN.R-project.org/package=rgph},   doi = {10.32614/CRAN.package.rgph}, }"},{"path":"/index.html","id":"rgph","dir":"","previous_headings":"","what":"Pair Critical Points and Compute Persistent Homology of Reeb Graphs","title":"Pair Critical Points and Compute Persistent Homology of Reeb Graphs","text":"Reeb graphs arise low-dimensional quotients topological spaces level set–based equivalence. Reeb graph’s topological structure informative original space quicker easier compute. rgph provides S3 class constructors Reeb graphs, bindings ReebGraphPairing Java library pairing critical points, post-processing extended persistent homology, methods accommodate igraph network objects streamline process.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Pair Critical Points and Compute Persistent Homology of Reeb Graphs","text":"can install development version rgph GitHub : expect submit CRAN soon!","code":"# install.packages(\"pak\") pak::pak(\"tdaverse/rgph\")"},{"path":"/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Pair Critical Points and Compute Persistent Homology of Reeb Graphs","text":"running example Tu, Hajij, Rosen (2019) can read installed data file: Reeb graph printout comprises edgelist. example, function value vertex (numbering convention) index vertex. R indexing starts 1, function values, printed parentheses, reflect original indexing 0. plot() method provided yet, layered layout igraph may helpful. negate values Reeb function vertices higher (original) values positioned higher plot:  low-dimensional, Reeb graphs intricate structures, whereas statistical applications require numerical summary statistics. meaningful topological signature Reeb graph (hence parent space) can obtained pairing critical points. Tu, Hajij, Rosen proposed clever single-pass algorithm, “propagate--pair”, outperformed multiple-pass algorithm (based standard procedures time) Reeb graphs included comparison. methods provided, user may control using method argument: end pairing either local extremum (minimum maximum) fork (upward downward). types indicated printout bullets inequality signs, respectively; refer plot see pairings exhaust vertex–edge incidences. pairing output can converted extended persistence diagrams using persistence class phutil plotted using diagram method TDA:  plot overlays 4 sub-diagrams, two lie diagonal encode features extended persistence whose births occur larger function values deaths (explained detail Carrière & Oudot (2018); compare Fig. 1 Tu, Hajij, Rosen): min–max pairs encode connected components, constitutive degree-\\(0\\) positive extended persistence; pair \\((1,16)\\) min–pairs encode merges, degree-\\(0\\) ordinary persistence; e.g. pair \\((5,7)\\) –max pairs encode splits, degree-\\(1\\) relative persistence; pair \\((15,14)\\) –pairs encode cycles, degree-\\(1\\) negative extended persistence; e.g. pair \\((13,9)\\)","code":"library(rgph) #> Loading required package: rJava #> Loading required package: phutil ( ex_file <- system.file(\"extdata/running_example.txt\", package = \"rgph\") ) #> [1] \"/Library/Frameworks/R.framework/Versions/4.2/Resources/library/rgph/extdata/running_example.txt\" ( ex_reeb <- read_reeb_graph(ex_file) ) #> Reeb graph with 16 vertices and 18 edges on [0,15]: #>  1 ( 0) --  3 ( 2) #>  2 ( 1) --  3 ( 2) #>  3 ( 2) --  4 ( 3) #>  4 ( 3) --  6 ( 5) #>  4 ( 3) --  7 ( 6) #>  5 ( 4) --  7 ( 6) #>  6 ( 5) -- 10 ( 9) #>  6 ( 5) -- 10 ( 9) #>  7 ( 6) -- 12 (11) #>  8 ( 7) --  9 ( 8) #>  9 ( 8) -- 12 (11) #>  9 ( 8) -- 11 (10) #> ... ex_igraph <- as_igraph(ex_reeb, values = \"depth\") ex_layout <- igraph::layout_with_sugiyama(   ex_igraph,   layers = -igraph::vertex_attr(ex_igraph, \"depth\") ) plot(ex_igraph, layout = ex_layout) ( ex_pairs <- reeb_graph_pairs(ex_reeb, method = \"single\") ) #> Reeb graph critical pairing (8 pairs): #>  1 ( 0) •- ... -• 16 (15) #>  2 ( 1) •- ... >-  3 ( 2) #>  5 ( 4) •- ... >-  7 ( 6) #>  8 ( 7) •- ... >- 11 (10) #>  6 ( 5) -< ... >- 10 ( 9) #>  4 ( 3) -< ... >- 12 (11) #>  9 ( 8) -< ... >- 13 (12) #> 14 (13) -< ... -• 15 (14) ( ex_ph <- reeb_graph_persistence(ex_pairs, scale = \"index\") ) #>  #> ── Persistence Data ──────────────────────────────────────────────────────────── #> ℹ There are 4 and 4 pairs in dimensions 0 and 1 respectively. #> ℹ Computed from a Extended Reeb (Sublevel) filtration using `rgph::reeb_graph_persistence()`. #> ℹ With the following parameters: method = 'single_pass' and scale = 'index'. TDA::plot.diagram(as.data.frame(ex_ph), asp = 1)"},{"path":"/reference/as_reeb_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"Coerce objects to class reeb_graph — as_reeb_graph","title":"Coerce objects to class reeb_graph — as_reeb_graph","text":"Coerce objects [reeb_graph]-class objects.","code":""},{"path":"/reference/as_reeb_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Coerce objects to class reeb_graph — as_reeb_graph","text":"","code":"as_reeb_graph(x, ...)  # S3 method for class 'igraph' as_reeb_graph(x, values = NULL, names = NULL, ...)  # S3 method for class 'network' as_reeb_graph(x, values = NULL, names = NULL, ...)  as_igraph(x, ...)  # S3 method for class 'reeb_graph' as_igraph(x, values = \"value\", names = \"name\", ...)  as_network(x, ...)  # S3 method for class 'reeb_graph' as_network(x, values = \"value\", names = \"vertex.names\", ...)"},{"path":"/reference/as_reeb_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Coerce objects to class reeb_graph — as_reeb_graph","text":"x R object coerced. See Details. ... Additional arguments passed methods. values coercion class reeb_graph, character value; node attribute use Reeb graph value function. NULL (default), first numeric node attribute used. coercion class reeb_graph, character value; name node attribute store Reeb graph value function. names coercion class reeb_graph, character value; node attribute use Reeb graph node names. NULL, names omitted. coercion class reeb_graph, character value; name node attribute store Reeb graph node names.","code":""},{"path":"/reference/as_reeb_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Coerce objects to class reeb_graph — as_reeb_graph","text":"reeb_graph object.","code":""},{"path":"/reference/as_reeb_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Coerce objects to class reeb_graph — as_reeb_graph","text":"as_reeb_graph() methods require network (mathematical graph) structure real-valued function vertex set. coercion external network classes, use intergraph package.","code":""},{"path":[]},{"path":"/reference/as_reeb_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Coerce objects to class reeb_graph — as_reeb_graph","text":"","code":"library(igraph) #>  #> Attaching package: ‘igraph’ #> The following objects are masked from ‘package:stats’: #>  #>     decompose, spectrum #> The following object is masked from ‘package:base’: #>  #>     union ( g <- make_kautz_graph(2, 1) ) #> IGRAPH b68061f D--- 6 12 -- Kautz graph 2-1 #> + attr: name (g/c), m (g/n), n (g/n) #> + edges from b68061f: #>  [1] 1->3 1->4 2->5 2->6 3->1 3->2 4->5 4->6 5->1 5->2 6->3 6->4 l_g <- layout_with_fr(g) plot(g, layout = l_g)  ( rg <- as_reeb_graph(g, l_g[, 1]) ) #> Reeb graph with 6 vertices and 12 edges on [-0.1062215,1.416511]: #> 1 ( 0.69397878) -- 3 ( 0.90169156) #> 1 ( 0.69397878) -- 4 ( 1.06662810) #> 2 (-0.02012786) -- 5 (-0.10622145) #> 2 (-0.02012786) -- 6 ( 1.41651091) #> 3 ( 0.90169156) -- 1 ( 0.69397878) #> 3 ( 0.90169156) -- 2 (-0.02012786) #> 4 ( 1.06662810) -- 5 (-0.10622145) #> 4 ( 1.06662810) -- 6 ( 1.41651091) #> 5 (-0.10622145) -- 1 ( 0.69397878) #> 5 (-0.10622145) -- 2 (-0.02012786) #> 6 ( 1.41651091) -- 3 ( 0.90169156) #> 6 ( 1.41651091) -- 4 ( 1.06662810) #>  vertex_attr(g, \"height\") <- rg$value heights <- sort(unique(V(g)$height)) l_rg <- layout_with_sugiyama(g, layers = round(V(g)$height * 100)) plot(g, layout = l_rg)  library(network) #>  #> ‘network’ 1.19.0 (2024-12-08), part of the Statnet Project #> * ‘news(package=\"network\")’ for changes since last version #> * ‘citation(\"network\")’ for citation information #> * ‘https://statnet.org’ for help, support, and other information #>  #> Attaching package: ‘network’ #> The following objects are masked from ‘package:igraph’: #>  #>     %c%, %s%, add.edges, add.vertices, delete.edges, delete.vertices, #>     get.edge.attribute, get.edges, get.vertex.attribute, is.bipartite, #>     is.directed, list.edge.attributes, list.vertex.attributes, #>     set.edge.attribute, set.vertex.attribute data(\"emon\") mtsi <- emon$Cheyenne mtsi_reeb <- as_reeb_graph(   mtsi,   values = \"Command.Rank.Score\",   names = \"vertex.names\" ) print(mtsi_reeb, minlength = 24) #> Reeb graph with 14 vertices and 83 edges on [0,40]: #>  2[W.S.N.G..] (10) --  1[W.D..C.D.] ( 0) #>  3[Wym.S.H.P] ( 3) --  1[W.D..C.D.] ( 0) #>  8[L.C...C.C] (40) --  1[W.D..C.D.] ( 0) #>  9[Chynn.F.D] (10) --  1[W.D..C.D.] ( 0) #> 14[S.W.HAM.R] ( 0) --  1[W.D..C.D.] ( 0) #>  1[W.D..C.D.] ( 0) --  2[W.S.N.G..] (10) #>  3[Wym.S.H.P] ( 3) --  2[W.S.N.G..] (10) #>  4[F.E..W.A.] ( 5) --  2[W.S.N.G..] (10) #>  8[L.C...C.C] (40) --  2[W.S.N.G..] (10) #>  1[W.D..C.D.] ( 0) --  3[Wym.S.H.P] ( 3) #>  2[W.S.N.G..] (10) --  3[Wym.S.H.P] ( 3) #>  4[F.E..W.A.] ( 5) --  3[Wym.S.H.P] ( 3) #> ..."},{"path":"/reference/reeb_graph.html","id":null,"dir":"Reference","previous_headings":"","what":"An S3 class and constructors for Reeb graphs — reeb_graph","title":"An S3 class and constructors for Reeb graphs — reeb_graph","text":"S3 class associated constructors data structure represent Reeb graphs R.","code":""},{"path":"/reference/reeb_graph.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"An S3 class and constructors for Reeb graphs — reeb_graph","text":"","code":"reeb_graph(values, edgelist)  # S3 method for class 'reeb_graph' print(x, ..., n = NULL, minlength = 12L)  # S3 method for class 'reeb_graph' format(x, ..., n = NULL, minlength = 12L)  read_reeb_graph(file)"},{"path":"/reference/reeb_graph.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"An S3 class and constructors for Reeb graphs — reeb_graph","text":"values Numeric vector function values vertices; may names, may duplicated /missing. edgelist 2-column integer matrix linked vertex pairs. x Object class reeb_graph. ... Additional arguments passed base::format(). n Integer number edges print. minlength Minimum name abbreviation length; passed base::abbreviate(). file plain text file containing Reeb graph data formatted ReebGraphPairing.","code":""},{"path":"/reference/reeb_graph.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"An S3 class and constructors for Reeb graphs — reeb_graph","text":"object class \"reeb_graph\", list two elements: values: Numeric vector function values vertices, optionally named. edgelist: 2-column integer matrix linked vertex pairs.","code":""},{"path":"/reference/reeb_graph.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"An S3 class and constructors for Reeb graphs — reeb_graph","text":"Vertex indices start zero, consistency examples. positions values integer values edgelist correspond vertices; length(values) must bound max(edgelist). S3 class list \"values\" \"edgelist\". print() method prints one edge per line, nodes formatted \"index[name] (value)\"","code":""},{"path":"/reference/reeb_graph.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"An S3 class and constructors for Reeb graphs — reeb_graph","text":"https://github.com/USFDataVisualization/ReebGraphPairing/","code":""},{"path":[]},{"path":"/reference/reeb_graph.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"An S3 class and constructors for Reeb graphs — reeb_graph","text":"","code":"x <- reeb_graph(   values = c(a = 0, b = .4, c = .6, d = 1),   edgelist = rbind( c(1,2), c(1,3), c(2,4), c(3,4)) ) print(x) #> Reeb graph with 4 vertices and 4 edges on [0,1]: #> 1[a] (0.0) -- 2[b] (0.4) #> 1[a] (0.0) -- 3[c] (0.6) #> 2[b] (0.4) -- 4[d] (1.0) #> 3[c] (0.6) -- 4[d] (1.0) #>   t10 <- system.file(\"extdata\", \"10_tree_iterations.txt\", package = \"rgph\") ( y <- read_reeb_graph(t10) ) #> Reeb graph with 41 vertices and 40 edges on [0,152.2565]: #>  1 ( 0.000000) --  2 ( 1.386294) #>  1 ( 0.000000) -- 14 (36.946803) #>  2 ( 1.386294) --  3 ( 3.295837) #>  3 ( 3.295837) --  4 ( 5.545177) #>  3 ( 3.295837) --  5 ( 8.047190) #>  4 ( 5.545177) --  6 (10.750557) #>  6 (10.750557) --  7 (13.621371) #>  7 (13.621371) --  9 (19.775021) #>  7 (13.621371) --  8 (16.635532) #>  8 (16.635532) -- 18 (52.026692) #>  9 (19.775021) -- 10 (23.025851) #> 10 (23.025851) -- 11 (26.376848) #> ...  reeb_graph_pairs(x, method = \"multi_pass\") #> Reeb graph critical pairing (2 pairs): #> 1[a] (0) •- ... -• 4[d] (1) #> 1[a] (0) -< ... >- 4[d] (1) #>  reeb_graph_pairs(y, method = \"multi_pass\") #> Reeb graph critical pairing (12 pairs): #>  1 (  0.000000) •- ... -• 41 (152.25645) #>  1 (  0.000000) -< ... -• 17 ( 48.16463) #>  3 (  3.295837) -< ... -•  5 (  8.04719) #>  7 ( 13.621371) -< ... -• 37 (133.60396) #> 11 ( 26.376848) -< ... -• 12 ( 29.81888) #> 15 ( 40.620754) -< ... -• 16 ( 44.36142) #> 19 ( 55.944340) -< ... -• 20 ( 59.91465) #> 23 ( 72.116364) -< ... -• 25 ( 80.47189) #> 27 ( 88.987595) -< ... -• 29 ( 97.65158) #> 31 (106.453606) -< ... -• 33 (115.38475) #> 35 (124.437180) -< ... -• 36 (129.00668) #> 39 (142.878906) -< ... -• 40 (147.55518) #>"},{"path":"/reference/reeb_graph_examples.html","id":null,"dir":"Reference","previous_headings":"","what":"Mesh-Derived Reeb Graphs — reeb_graph_examples","title":"Mesh-Derived Reeb Graphs — reeb_graph_examples","text":"Reeb graphs used Tu &al (2019; Fig. 8) benchmark multi-pass single-pass algorithms. original meshes obtained AIM@SHAPE Shape Repository, authors computed Reeb graphs using custom C++ implementation.","code":""},{"path":"/reference/reeb_graph_examples.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mesh-Derived Reeb Graphs — reeb_graph_examples","text":"","code":"david buddha topology flower"},{"path":"/reference/reeb_graph_examples.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Mesh-Derived Reeb Graphs — reeb_graph_examples","text":"Objects class reeb_graph.","code":""},{"path":"/reference/reeb_graph_examples.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Mesh-Derived Reeb Graphs — reeb_graph_examples","text":"http://visionair.ge.imati.cnr./ontologies/shapes/ (AIM@SHAPE; defunct) https://github.com/USFDataVisualization/ReebGraphPairing","code":""},{"path":"/reference/reeb_graph_pairs.html","id":null,"dir":"Reference","previous_headings":"","what":"Pair Reeb Graph Critical Points via Java — reeb_graph_pairs","title":"Pair Reeb Graph Critical Points via Java — reeb_graph_pairs","text":"function calls one two methods, merge-pair propagate--pair, pair critical points Reeb graph.","code":""},{"path":"/reference/reeb_graph_pairs.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pair Reeb Graph Critical Points via Java — reeb_graph_pairs","text":"","code":"reeb_graph_pairs(   x,   sublevel = TRUE,   method = c(\"single_pass\", \"multi_pass\"),   ... )  # Default S3 method reeb_graph_pairs(   x,   sublevel = TRUE,   method = c(\"single_pass\", \"multi_pass\"),   ... )  # S3 method for class 'igraph' reeb_graph_pairs(   x,   sublevel = TRUE,   method = c(\"single_pass\", \"multi_pass\"),   values = NULL,   ... )  # S3 method for class 'network' reeb_graph_pairs(   x,   sublevel = TRUE,   method = c(\"single_pass\", \"multi_pass\"),   values = NULL,   ... )  # S3 method for class 'reeb_graph' reeb_graph_pairs(   x,   sublevel = TRUE,   method = c(\"single_pass\", \"multi_pass\"),   ... )  # S3 method for class 'reeb_graph_pairs' as.data.frame(x, ...)  # S3 method for class 'reeb_graph_pairs' print(x, ..., n = NULL, minlength = 12L)  # S3 method for class 'reeb_graph_pairs' format(x, ..., n = NULL, minlength = 12L)"},{"path":"/reference/reeb_graph_pairs.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pair Reeb Graph Critical Points via Java — reeb_graph_pairs","text":"x reeb_graph object. sublevel Logical; whether use sublevel set filtration (TRUE, default) else superlevel set filtration (via reversing x[[\"values\"]] paring critical points. method Character; pairing method use. Matched \"single_pass\" (default) \"multi_pass\". ... Additional arguments passed methods. values coercion class reeb_graph, character value; node attribute use Reeb graph value function. NULL (default), first numeric node attribute used. coercion class reeb_graph, character value; name node attribute store Reeb graph value function. n Integer number critical pairs print. minlength Minimum name abbreviation length; passed base::abbreviate().","code":""},{"path":"/reference/reeb_graph_pairs.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pair Reeb Graph Critical Points via Java — reeb_graph_pairs","text":"list subclass reeb_graph_pairs containing 4 2-column matrices characterizing low- high-valued critical points pair: type Character; type critical point, one LEAF_MIN, LEAF_MAX, UPFORK, DOWNFORK. value Double; value (stored x[[\"values\"]]) critical point. index Integer; index (used x[[\"edgelist\"]]) critical point. Regular points appear, degenerate critical points appear multiple times. order Integer; order critical point pairing. based conditioned Reeb graph constructed internally duplicated. data frame also attributes \"names\" node names, \"method\" method used, \"elapsed_time\" elapsed time.","code":""},{"path":"/reference/reeb_graph_pairs.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Pair Reeb Graph Critical Points via Java — reeb_graph_pairs","text":"function uses rJava package call either two Java methods ReebGraphPairing. Ensure Java Virtual Machine (JVM) initialized required class available class path. Propagate--Pair algorithm (\"single_pass\") performs join split merge tree operations along single sweep Reeb graph. shown efficient test data, scale better graph size, algorithm (\"multi_pass\") pairs types along sublevel filtration others along superlevel filtration (Tu &al, 2019). output S3 class list 2-column matrices containing types, values, indices, orders persistent pairs, attributes containing node names metadata. print() method visually expresses pair, increasing left right, nodes formatted reeb_graph. names coerced data frame use lo_ hi_ prefixes, contrast Java source code uses birth_ death_. meant distinguish pairs metadata persistent homology, reformulated following Carrière & Oudot (2018).","code":""},{"path":"/reference/reeb_graph_pairs.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Pair Reeb Graph Critical Points via Java — reeb_graph_pairs","text":"https://github.com/USFDataVisualization/ReebGraphPairing/ Tu J, Hajij M, Rosen P. Propagate Pair: Single-Pass Approach Critical Point Pairing Reeb Graphs. : Bebis G, Boyle R, Parvin B, &al, eds. Advances Visual Computing. Lecture Notes Computer Science. Springer International Publishing; 2019:99–113. doi:10.1007/978-3-030-33720-9_8 Carrière M & Oudot S (2018) \"Structure Stability One-Dimensional Mapper\". Foundations Computational Mathematics 18(6): 1333–1396. doi:10.1007/s10208-017-9370-z","code":""},{"path":[]},{"path":"/reference/reeb_graph_pairs.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pair Reeb Graph Critical Points via Java — reeb_graph_pairs","text":"","code":"ex_sf <- system.file(\"extdata\", \"running_example.txt\", package = \"rgph\") ( ex_rg <- read_reeb_graph(ex_sf) ) #> Reeb graph with 16 vertices and 18 edges on [0,15]: #>  1 ( 0) --  3 ( 2) #>  2 ( 1) --  3 ( 2) #>  3 ( 2) --  4 ( 3) #>  4 ( 3) --  6 ( 5) #>  4 ( 3) --  7 ( 6) #>  5 ( 4) --  7 ( 6) #>  6 ( 5) -- 10 ( 9) #>  6 ( 5) -- 10 ( 9) #>  7 ( 6) -- 12 (11) #>  8 ( 7) --  9 ( 8) #>  9 ( 8) -- 12 (11) #>  9 ( 8) -- 11 (10) #> ... ( ex_cp <- reeb_graph_pairs(ex_rg) ) #> Reeb graph critical pairing (8 pairs): #>  1 ( 0) •- ... -• 16 (15) #>  2 ( 1) •- ... >-  3 ( 2) #>  5 ( 4) •- ... >-  7 ( 6) #>  8 ( 7) •- ... >- 11 (10) #>  6 ( 5) -< ... >- 10 ( 9) #>  4 ( 3) -< ... >- 12 (11) #>  9 ( 8) -< ... >- 13 (12) #> 14 (13) -< ... -• 15 (14) #>  attr(ex_cp, \"method\") #> [1] \"single_pass\" attr(ex_cp, \"elapsed_time\") #> [1] 0.1093791  reeb_graph_pairs(ex_rg, sublevel = FALSE) #> Reeb graph critical pairing (8 pairs): #> 16 (15) •- ... -•  1 ( 0) #> 15 (14) •- ... >- 14 (13) #> 11 (10) -< ... -•  8 ( 7) #> 13 (12) -< ... >-  9 ( 8) #>  7 ( 6) -< ... -•  5 ( 4) #> 10 ( 9) -< ... >-  6 ( 5) #> 12 (11) -< ... >-  4 ( 3) #>  3 ( 2) -< ... -•  2 ( 1) #>   x <- reeb_graph(   values = c(0, .4, .6, 1),   edgelist = c( 1,2, 1,3, 2,4, 3,4 ) ) ( mp <- reeb_graph_pairs(x) ) #> Reeb graph critical pairing (2 pairs): #> 1 (0) •- ... -• 4 (1) #> 1 (0) -< ... >- 4 (1) #>  class(mp) #> [1] \"reeb_graph_pairs\" \"list\"             as.data.frame(mp) #>    lo_type  hi_type lo_value hi_value lo_index hi_index lo_order hi_order #> 1 LEAF_MIN LEAF_MAX        0        1        1        4        1        4 #> 2   UPFORK DOWNFORK        0        1        1        4        2        3  names(x$values) <- letters[seq_along(x$values)] ( mp <- reeb_graph_pairs(x) ) #> Reeb graph critical pairing (2 pairs): #> 1[a] (0) •- ... -• 4[d] (1) #> 1[a] (0) -< ... >- 4[d] (1) #>  as.data.frame(mp) #>    lo_type  hi_type lo_value hi_value lo_index hi_index lo_order hi_order #> 1 LEAF_MIN LEAF_MAX        0        1        1        4        1        4 #> 2   UPFORK DOWNFORK        0        1        1        4        2        3 #>   lo_name hi_name #> 1       a       d #> 2       a       d  library(network) data(\"emon\") mtsi <- emon$Cheyenne mtsi_reeb <- as_reeb_graph(   mtsi,   values = \"Command.Rank.Score\",   names = \"vertex.names\" ) mtsi_cp <- reeb_graph_pairs(mtsi_reeb, sublevel = FALSE) print(mtsi_cp, minlength = 20) #> Reeb graph critical pairing (72 pairs): #>  8[L.C...C.C] (40) •- ... -• 14[S.W.HAM.R] ( 0) #>  8[L.C...C.C] (40) -< ... >-  7[Lr.C.S..O] (20) #>  8[L.C...C.C] (40) -< ... >-  7[Lr.C.S..O] (20) #> 10[Chynn.P.D] (30) -< ... >-  7[Lr.C.S..O] (20) #>  8[L.C...C.C] (40) -< ... >-  2[W.S.N.G..] (10) #>  8[L.C...C.C] (40) -< ... >-  2[W.S.N.G..] (10) #> 10[Chynn.P.D] (30) -< ... >-  2[W.S.N.G..] (10) #>  7[Lr.C.S..O] (20) -< ... >-  9[Chynn.F.D] (10) #>  8[L.C...C.C] (40) -< ... >-  9[Chynn.F.D] (10) #> 10[Chynn.P.D] (30) -< ... >-  9[Chynn.F.D] (10) #> 10[Chynn.P.D] (30) -< ... >-  9[Chynn.F.D] (10) #>  8[L.C...C.C] (40) -< ... >-  9[Chynn.F.D] (10) #>"},{"path":"/reference/reeb_graph_persistence.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Extended Persistent Homology of a Reeb Graph — reeb_graph_persistence","title":"Compute Extended Persistent Homology of a Reeb Graph — reeb_graph_persistence","text":"function obtains extended persistent homology Reeb graph way pairing critical points.","code":""},{"path":"/reference/reeb_graph_persistence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Extended Persistent Homology of a Reeb Graph — reeb_graph_persistence","text":"","code":"reeb_graph_persistence(x, scale = c(\"value\", \"index\", \"order\"), ...)  # Default S3 method reeb_graph_persistence(x, scale = c(\"value\", \"index\", \"order\"), ...)  # S3 method for class 'igraph' reeb_graph_persistence(   x,   scale = c(\"value\", \"index\", \"order\"),   sublevel = TRUE,   method = c(\"single_pass\", \"multi_pass\"),   values = NULL,   ... )  # S3 method for class 'network' reeb_graph_persistence(   x,   scale = c(\"value\", \"index\", \"order\"),   sublevel = TRUE,   method = c(\"single_pass\", \"multi_pass\"),   values = NULL,   ... )  # S3 method for class 'reeb_graph' reeb_graph_persistence(   x,   scale = c(\"value\", \"index\", \"order\"),   sublevel = TRUE,   method = c(\"single_pass\", \"multi_pass\"),   ... )  # S3 method for class 'reeb_graph_pairs' reeb_graph_persistence(x, scale = c(\"value\", \"index\", \"order\"), ...)"},{"path":"/reference/reeb_graph_persistence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Extended Persistent Homology of a Reeb Graph — reeb_graph_persistence","text":"x reeb_graph reeb_graph_pairs object, object can coerced class \"reeb_graph\". scale Character; scale parameter used persistent pairs. Matched \"value\" (default), \"index\", \"order\". ... Additional arguments passed methods. sublevel Logical; whether use sublevel set filtration (TRUE, default) else superlevel set filtration (via reversing x[[\"values\"]] paring critical points. method Character; pairing method use. Matched \"single_pass\" (default) \"multi_pass\". values coercion class reeb_graph, character value; node attribute use Reeb graph value function. NULL (default), first numeric node attribute used. coercion class reeb_graph, character value; name node attribute store Reeb graph value function.","code":""},{"path":"/reference/reeb_graph_persistence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Extended Persistent Homology of a Reeb Graph — reeb_graph_persistence","text":"phutil::persistence object.","code":""},{"path":"/reference/reeb_graph_persistence.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Extended Persistent Homology of a Reeb Graph — reeb_graph_persistence","text":"types, values, indices critical pairs obtained reeb_graph_pairs(). reeb_graph_persistence() calls function internally prescribed method, restructures values indices phutil::persistence data. function may deprecated reeb_graph_pairs method written phutil::as_persistence().","code":""},{"path":[]},{"path":"/reference/reeb_graph_persistence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Extended Persistent Homology of a Reeb Graph — reeb_graph_persistence","text":"","code":"ex_sf <- system.file(\"extdata\", \"running_example.txt\", package = \"rgph\") ( ex_rg <- read_reeb_graph(ex_sf) ) #> Reeb graph with 16 vertices and 18 edges on [0,15]: #>  1 ( 0) --  3 ( 2) #>  2 ( 1) --  3 ( 2) #>  3 ( 2) --  4 ( 3) #>  4 ( 3) --  6 ( 5) #>  4 ( 3) --  7 ( 6) #>  5 ( 4) --  7 ( 6) #>  6 ( 5) -- 10 ( 9) #>  6 ( 5) -- 10 ( 9) #>  7 ( 6) -- 12 (11) #>  8 ( 7) --  9 ( 8) #>  9 ( 8) -- 12 (11) #>  9 ( 8) -- 11 (10) #> ... ( ex_ph <- reeb_graph_persistence(ex_rg) ) #>  #> ── Persistence Data ──────────────────────────────────────────────────────────── #> ℹ There are 4 and 4 pairs in dimensions 0 and 1 respectively. #> ℹ Computed from a Extended Reeb (Sublevel) filtration using `rgph::reeb_graph_persistence()`. #> ℹ With the following parameters: method = 'single_pass' and scale = 'value'. phutil::get_pairs(ex_ph, dimension = 0) #>      [,1] [,2] #> [1,]    1    2 #> [2,]    4    6 #> [3,]    7   10 #> [4,]    0   15 phutil::get_pairs(ex_ph, dimension = 1) #>      [,1] [,2] #> [1,]   14   13 #> [2,]    9    5 #> [3,]   11    3 #> [4,]   12    8  t10_f <- system.file(\"extdata\", \"10_tree_iterations.txt\", package = \"rgph\") ( t10 <- read_reeb_graph(t10_f) ) #> Reeb graph with 41 vertices and 40 edges on [0,152.2565]: #>  1 ( 0.000000) --  2 ( 1.386294) #>  1 ( 0.000000) -- 14 (36.946803) #>  2 ( 1.386294) --  3 ( 3.295837) #>  3 ( 3.295837) --  4 ( 5.545177) #>  3 ( 3.295837) --  5 ( 8.047190) #>  4 ( 5.545177) --  6 (10.750557) #>  6 (10.750557) --  7 (13.621371) #>  7 (13.621371) --  9 (19.775021) #>  7 (13.621371) --  8 (16.635532) #>  8 (16.635532) -- 18 (52.026692) #>  9 (19.775021) -- 10 (23.025851) #> 10 (23.025851) -- 11 (26.376848) #> ... ( t10_ph <- reeb_graph_persistence(t10) ) #>  #> ── Persistence Data ──────────────────────────────────────────────────────────── #> ℹ There are 1 and 11 pairs in dimensions 0 and 1 respectively. #> ℹ Computed from a Extended Reeb (Sublevel) filtration using `rgph::reeb_graph_persistence()`. #> ℹ With the following parameters: method = 'single_pass' and scale = 'value'. phutil::get_pairs(t10_ph, dimension = 0) #>      [,1]     [,2] #> [1,]    0 152.2565 ( t10_ph <- reeb_graph_persistence(t10, scale = \"index\") ) #>  #> ── Persistence Data ──────────────────────────────────────────────────────────── #> ℹ There are 1 and 11 pairs in dimensions 0 and 1 respectively. #> ℹ Computed from a Extended Reeb (Sublevel) filtration using `rgph::reeb_graph_persistence()`. #> ℹ With the following parameters: method = 'single_pass' and scale = 'index'. phutil::get_pairs(t10_ph, dimension = 0) #>      [,1] [,2] #> [1,]    1   41 ( t10_ph <- reeb_graph_persistence(t10, scale = \"order\") ) #>  #> ── Persistence Data ──────────────────────────────────────────────────────────── #> ℹ There are 1 and 11 pairs in dimensions 0 and 1 respectively. #> ℹ Computed from a Extended Reeb (Sublevel) filtration using `rgph::reeb_graph_persistence()`. #> ℹ With the following parameters: method = 'single_pass' and scale = 'order'. phutil::get_pairs(t10_ph, dimension = 0) #>      [,1] [,2] #> [1,]    1   24"},{"path":"/reference/rgph.html","id":null,"dir":"Reference","previous_headings":"","what":"rgph: Pair Critical Points and Compute Persistent Homology of Reeb Graphs — rgph","title":"rgph: Pair Critical Points and Compute Persistent Homology of Reeb Graphs — rgph","text":"Interface 'ReebGraphPairing' program compute critical points Reeb graphs following Tu, Hajij, & Rosen (2019) doi:10.1007/978-3-030-33720-9_8  via 'rJava' package. Also store Reeb graphs minimal S3 class, convert network data structures, post-process pairing data obtain extended persistent homology following Carrière & Oudot (2018) doi:10.1007/s10208-017-9370-z .","code":""},{"path":"/reference/rgph.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"rgph: Pair Critical Points and Compute Persistent Homology of Reeb Graphs — rgph","text":"Maintainer: Jason Cory Brunson cornelioid@gmail.com (ORCID) Authors: Satyajit Mohanty mohantysatyajit57@gmail.com Shubham Singh shubhamus16091998@example.com contributors: Paul Rosen paul.rosen@utah.edu (ORCID) (ReebGraphPairing; GPL-3 license) [copyright holder, contributor] Junyi Tu JXTU@salisbury.edu (ORCID) (ReebGraphPairing; GPL-3 license) [copyright holder, contributor]","code":""},{"path":"/news/index.html","id":"rgph-010","dir":"Changelog","previous_headings":"","what":"rgph 0.1.0","title":"rgph 0.1.0","text":"Initial CRAN submission.","code":""}]
